#!/usr/bin/python3

import contextlib
from pprint import pprint
from typing import Generator, Iterable

try:
    import requests
except ImportError:
    print("Run `python3 -m pip install requests` to use this generator.")
    exit(1)

IEC_URL = "https://raw.githubusercontent.com/wayland-project/libinput/master/include/linux/linux/input-event-codes.h"
BANNED_KEYWORDS = ["RESERVED"]

res = requests.get(IEC_URL)

lines = res.text.splitlines()
doc: dict[str, dict[int, str]] = {}

def iter_lines(l: list) -> Generator:
    lines: Iterable[str] = iter(l)
    # get to start
    while True:
        try:
            line = next(lines)
        except StopIteration:
            print("Missing starting line.")
            exit(1)
        if "Device properties and quirks" in line:
            break
    # read file
    while True:
        try:
            line = next(lines)
        except StopIteration:
            break
        if line.startswith("#define"):
            line = line.removeprefix("#define ")
            segs = split_whitespace(line)
            group, name = segs[0].split("_", 1)
            base = 16 if "x" in segs[1] else 10
            with contextlib.suppress(ValueError):
                code = int(segs[1].split(" ")[0], base=base)
                yield group, name, code
        
def split_whitespace(raw: str) -> list[str]:
    whitespace = ["\t", " "]
    segments = []
    white = True
    for char in raw:
        if white and char not in whitespace:
                white = False
                segments.append(char)
        elif char in whitespace:
            white = True
        else:
            segments[-1] += char

    return segments

for group, name, code in iter_lines(lines):
    if name not in BANNED_KEYWORDS:
        if doc.get(group) is None:
            doc[group] = {}
        doc[group][code] = name

def format_classname(group: str, raw: str) -> str:
    words = raw.split("_")
    name = "".join(word.lower().capitalize() for word in words)
    try: 
        int(name[0])
        name = f"{group.lower().capitalize()}{name}"
    except ValueError:
        ...
    return name

with open("src/enums.rs", "w") as fs:
    file = (
        "// This file was automatically generated by a Python script.\n"
        "// It requires the `requests` package to run.\n\n"
    )
    for group, val in doc.items():
        enum = f"pub enum {group}" + " {"
        for _, name in val.items():
            enum += "\n    " + format_classname(group, name) + ","
        enum += "\n}\n\n"
        file += enum

    fs.write(file)

with open("src/converters.rs", "w") as fs:
    file = (
        "// This file was automatically generated by a Python script.\n"
        "// It requires the `requests` package to run.\n\n"
        "use crate::enums;\n\n"
    )
    for group, val in doc.items():
        fn = (
            f"impl TryFrom<u16> for enums::{group}"" {\n"
            "    type Error = ();\n\n"
            "    fn try_from(key: u16) -> Result<Self, ()> {\n"
            "        match key {"
        )
        for key, name in val.items():
            fn += f"\n            {key} => Ok(enums::{group}::{format_classname(group, name)}),"
        fn += "\n            _ => Err(())\n        }\n    }\n}\n\n"
        file += fn

    for group, val in doc.items():
        fn = (
            f"impl From<enums::{group}> for String"" {\n"
            f"    fn from(event: enums::{group}) -> Self"" {\n"
            "        match event {"
        )
        for key, name in val.items():
            fn += f"\n            enums::{group}::{format_classname(group, name)} => String::from(\"{name}\"),"
        fn += "\n        }\n    }\n}\n"
        file += fn
    
    fs.write(file)